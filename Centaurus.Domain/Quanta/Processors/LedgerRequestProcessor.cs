using System;
using System.Collections.Generic;
using System.Text;
using Centaurus.Models;
using stellar_dotnet_sdk;

namespace Centaurus.Domain
{
    public class LedgerRequestProcessor : IQuantumRequestProcessor
    {
        public MessageTypes SupportedMessageType => MessageTypes.LedgerCommitQuantum;

        public ResultMessage Process(MessageEnvelope envelope)
        {
            var ledgerQuantum = (LedgerCommitQuantum)envelope.Message;
            var ledgerNotification = (LedgerUpdateNotification)ledgerQuantum.Source.Message;

            Global.LedgerManager.SetLedger(ledgerNotification.LedgerTo);

            for (var i = 0; i < ledgerNotification.Payments.Count; i++)
            {
                var payment = ledgerNotification.Payments[i];

                switch (payment.Type)
                {
                    case PaymentTypes.Deposit:
                        ProcessDeposite(payment as Deposit);
                        break;
                    case PaymentTypes.Withdrawal:
                        ProcessWithdrawal(payment as Withdrawal);
                        break;
                    default:
                        throw new InvalidOperationException("Unsupported payment type");
                }
            }

            return envelope.CreateResult(ResultStatusCodes.Success);
        }

        public void Validate(MessageEnvelope envelope)
        {
            //TODO: validate type automatically based on the SupportedMessageType
            var ledgerQuantum = envelope.Message as LedgerCommitQuantum
                ?? throw new ArgumentException($"Unexpected message type. Only messages of type {typeof(LedgerCommitQuantum).FullName} are supported.");

            var ledgerSourceEnvelope = ledgerQuantum.Source;
            var ledgerInfo = ledgerSourceEnvelope.Message as LedgerUpdateNotification
                ?? throw new ArgumentException($"Unexpected LedgerCommitQuantum source. Only messages of {typeof(LedgerUpdateNotification).FullName} type can be the source.");

            //no need to check signatures if code is running on Alpha, because the quantum is generated by it
            if (!Global.IsAlpha)
                CheckSignatures(ledgerSourceEnvelope);

            if (!Global.LedgerManager.IsValidNextLedger(ledgerInfo.LedgerFrom))
                throw new InvalidOperationException($"Ledger is invalid. Current ledger is {Global.LedgerManager.Ledger} and received ledger range starts with {ledgerInfo.LedgerFrom}");

            foreach (var payment in ledgerInfo.Payments)
            {
                switch (payment.Type)
                {
                    case PaymentTypes.Deposit:
                        ValidateDeposite(payment as Deposit);
                        break;
                    case PaymentTypes.Withdrawal:
                        ValidateWithdrawal(payment as Withdrawal);
                        break;
                    default:
                        throw new InvalidOperationException("Unsupported payment type: " + payment.Type.ToString());
                }
            }
        }

        private void CheckSignatures(MessageEnvelope envelope)
        {
            if (!MajorityHelper.HasMajority(envelope))
                throw new InvalidOperationException("No majority");

            if (!envelope.AreSignaturesValid())
                throw new InvalidOperationException("Signatures is invalid");
        }

        private void ValidateDeposite(Deposit deposite)
        {
            if (deposite == null)
                throw new ArgumentNullException(nameof(deposite));

            if (deposite.Destination == null || deposite.Destination.IsZero())
                throw new InvalidOperationException("Destination should be valid public key");

            if (deposite.Amount <= 0)
                throw new InvalidOperationException("Amount should be greater than 0");
        }

        private void ProcessDeposite(Deposit deposite)
        {
            if (deposite.PaymentResult == PaymentResults.Failed)
                return;
            var account = Global.AccountStorage.GetAccount(deposite.Destination);
            if (account == null)
                account = Global.AccountStorage.CreateAccount(deposite.Destination, null);

            var balance = account.GetBalance(deposite.Asset, true);
            balance.UpdateBalance(deposite.Amount);
        }

        private void ValidateWithdrawal(Withdrawal withdrawal)
        {
            if (withdrawal == null)
                throw new ArgumentNullException(nameof(withdrawal));

            if (withdrawal.Source == null || withdrawal.Source.IsZero())
                throw new InvalidOperationException("Source should be valid public key");

            if (withdrawal.Amount <= 0)
                throw new InvalidOperationException("Amount should be greater than 0");
        }

        private void ProcessWithdrawal(Withdrawal withdrawal)
        {
            var account = Global.AccountStorage.GetAccount(withdrawal.Source);
            if (account == null)
                account = Global.AccountStorage.CreateAccount(withdrawal.Source, null);

            var balance = account.GetBalance(withdrawal.Asset);

            balance.UnlockLiabilities(withdrawal.Amount);

            if (withdrawal.PaymentResult == PaymentResults.Success)
                balance.UpdateBalance(-withdrawal.Amount);
        }
    }
}
