using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Centaurus.Models;
using stellar_dotnet_sdk;

namespace Centaurus.Domain
{
    public class TxCommitProcessor : QuantumRequestProcessor<LedgerCommitProcessorContext>
    {
        public override MessageTypes SupportedMessageType => MessageTypes.TxCommitQuantum;

        public override Task<ResultMessage> Process(LedgerCommitProcessorContext context)
        {
            var ledgerQuantum = (TxCommitQuantum)context.Envelope.Message;
            var ledgerNotification = (TxNotification)ledgerQuantum.Source.Message;

            context.EffectProcessors.AddCursorUpdate(context.CentaurusContext.TxCursorManager, ledgerNotification.TxCursor, context.CentaurusContext.TxCursorManager.TxCursor);

            for (var i = 0; i < ledgerNotification.Payments.Count; i++)
            {
                var payment = ledgerNotification.Payments[i];

                switch (payment.Type)
                {
                    case PaymentTypes.Deposit:
                        ProcessDeposit(payment as Deposit, context);
                        break;
                    case PaymentTypes.Withdrawal:
                        ProcessWithdrawal(payment as Withdrawal, context);
                        break;
                    default:
                        throw new InvalidOperationException("Unsupported payment type");
                }
            }

            return Task.FromResult(context.Envelope.CreateResult(ResultStatusCodes.Success, context.EffectProcessors.Effects));
        }

        public override Task Validate(LedgerCommitProcessorContext context)
        {
            //TODO: validate type automatically based on the SupportedMessageType
            var ledgerQuantum = context.Envelope.Message as TxCommitQuantum
                ?? throw new ArgumentException($"Unexpected message type. Only messages of type {typeof(TxCommitQuantum).FullName} are supported.");
            var ledgerSourceEnvelope = ledgerQuantum.Source;
            var ledgerInfo = ledgerSourceEnvelope.Message as TxNotification
                ?? throw new ArgumentException($"Unexpected LedgerCommitQuantum source. Only messages of {typeof(TxNotification).FullName} type can be the source.");

            //no need to check signatures if code is running on Alpha, because the quantum is generated by it
            if (!context.CentaurusContext.IsAlpha)
                CheckSignatures(context.CentaurusContext, ledgerSourceEnvelope);

            if (!context.CentaurusContext.TxCursorManager.IsValidNewCursor(ledgerInfo.TxCursor))
                throw new InvalidOperationException($"Cursor is invalid. Current cursor is {context.CentaurusContext.TxCursorManager.TxCursor} and received was {ledgerInfo.TxCursor}");

            foreach (var payment in ledgerInfo.Payments)
            {
                switch (payment.Type)
                {
                    case PaymentTypes.Deposit:
                        ValidateDeposit(payment as Deposit);
                        break;
                    case PaymentTypes.Withdrawal:
                        ValidateWithdrawal(payment as Withdrawal, context);
                        break;
                    default:
                        throw new InvalidOperationException("Unsupported payment type: " + payment.Type.ToString());
                }
            }

            return Task.CompletedTask;
        }

        private void CheckSignatures(ExecutionContext context, MessageEnvelope envelope)
        {
            if (!context.HasMajority(envelope))
                throw new InvalidOperationException("No majority");

            if (!envelope.AreSignaturesValid())
                throw new InvalidOperationException("Signatures is invalid");
        }

        private void ValidateDeposit(Deposit deposit)
        {
            if (deposit == null)
                throw new ArgumentNullException(nameof(deposit));

            if (deposit.Destination == null || deposit.Destination.IsZero())
                throw new InvalidOperationException("Destination should be valid public key");

            if (deposit.Amount <= 0)
                throw new InvalidOperationException("Amount should be greater than 0");
        }

        /// <summary>
        /// Creates balance and account if needed, updates balance
        /// </summary>
        private void ProcessDeposit(Deposit deposit, LedgerCommitProcessorContext context)
        {
            if (deposit.PaymentResult == PaymentResults.Failed)
                return;

            var account = context.CentaurusContext.AccountStorage.GetAccount(deposit.Destination);
            if (account == null)
            {
                //ignore registration with non-native asset or with amount that is less than MinAccountBalance
                if (deposit.Asset != 0 || deposit.Amount < context.CentaurusContext.Constellation.MinAccountBalance)
                    return;
                var accId = context.CentaurusContext.AccountStorage.NextAccountId;
                context.EffectProcessors.AddAccountCreate(context.CentaurusContext.AccountStorage, accId, deposit.Destination);
                account = context.CentaurusContext.AccountStorage.GetAccount(accId);
            }

            if (!account.Account.HasBalance(deposit.Asset))
            {
                context.EffectProcessors.AddBalanceCreate(account, deposit.Asset);
            }

            context.EffectProcessors.AddBalanceUpdate(account, deposit.Asset, deposit.Amount);
        }

        private void ValidateWithdrawal(Withdrawal withdrawalModel, LedgerCommitProcessorContext context)
        {
            if (withdrawalModel == null)
                throw new ArgumentNullException(nameof(withdrawalModel));

            var withdrawal = context.CentaurusContext.WithdrawalStorage.GetWithdrawal(withdrawalModel.TransactionHash);
            if (withdrawal == null)
                throw new InvalidOperationException($"Withdrawal with hash '{withdrawalModel.TransactionHash.ToHex().ToLower()}' is not found.");
            context.Withdrawals.Add(withdrawalModel, withdrawal);
        }

        private void ProcessWithdrawal(Withdrawal withdrawalModel, LedgerCommitProcessorContext context)
        {
            var withdrawal = context.Withdrawals[withdrawalModel];
            if (withdrawalModel.PaymentResult != PaymentResults.Success)
            {
                //TODO: we need to notify client that something went wrong
            }
            context.EffectProcessors.AddWithdrawalRemove(withdrawal, withdrawalModel.PaymentResult == PaymentResults.Success, context.CentaurusContext.WithdrawalStorage);
        }

        public override LedgerCommitProcessorContext GetContext(EffectProcessorsContainer container)
        {
            return new LedgerCommitProcessorContext(container);
        }
    }
}
